---
title: 'hot100'
date: 2025-01-24
permalink: /posts/2025/01/hot100/
tags:
  - coding
---

        2025-1-24开始刷hot100，计划2025-03-15前刷完。最近一次更新是<u>2025-01-26</u>。

# 一眼不会写

* [221. 最大正方形 - 力扣（LeetCode）](https://leetcode.cn/problems/maximal-square/)

        没想到是dp 利用`min{dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}`就可以判断最右下角的`1`能否合一起构成一个大正方形，想到了还是比较easy的。

![fig1](https://assets.leetcode-cn.com/solution-static/221/221_fig1.png)

```cpp
class Solution {
public:
    int dp[300][300];
    int maximalSquare(vector<vector<char>>& matrix) {
        int ans=0;
        for(int i = 0; i < matrix.size(); i++){
            for(int j = 0; j < matrix[i].size(); j++){
                if(matrix[i][j]=='1'){
                    if(i==0||j==0) dp[i][j]=1;
                    else dp[i][j]=min(min(dp[i-1][j],dp[i-1][j-1]),dp[i][j-1]) + 1;
                }
                ans = max(ans,dp[i][j]);
            }
        }
        return ans * ans;
    }
};
```

# 非一边过

* [236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

内存超限，给每一个节点的父节点都用栈存起来了。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
void check(TreeNode* node, map<TreeNode*, stack<TreeNode*>> &mp){
    if(node->left!=nullptr){
        mp[node->left] = mp[node];
        mp[node->left].push(node->left);
        check(node->left, mp);
    }
    if(node->right!=nullptr){
        mp[node->right] = mp[node];
        mp[node->right].push(node->right);
        check(node->right, mp);
    }
    return;
} 

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        TreeNode* r = root;
        map<TreeNode*, stack<TreeNode*>> mp;
        check(root, mp);
        unordered_set<TreeNode*> s;
        while(!mp[p].empty()) {
            s.insert(mp[p].top());
            mp[p].pop();
        }
        while(!mp[q].empty()){
            if(s.count(mp[q].top())) return mp[q].top();
            mp[q].pop();
        }
        return root;
    }
};
```

稍微修改了一点，看到题目中的键值各不相同，所以只存父节点指针。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    map<int, TreeNode*> mp;

    void check(TreeNode* node){
        if(node->left!=nullptr){
            mp[node->left->val] = node;
            check(node->left);
        }
        if(node->right!=nullptr){
            mp[node->right->val] = node;
            check(node->right);
        }
        return;
    } 

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        TreeNode* r = root;
        check(root);
        unordered_set<TreeNode*> s;
        TreeNode *i = p, *j = q;
        while(i!=nullptr) {
            s.insert(i);
            i = mp[i->val];
        }
        while(j!=nullptr){
            if(s.count(j)) return j;
            j = mp[j->val];
        }
        return root;
    }
};
```

* [739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/)

没有想到非暴力做法，使用单调栈

```python
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> s;
        for(int i = 0; i < n; i++){
            while(!s.empty() && temperatures[i] > temperatures[s.top()]){
                ans[s.top()] = i - s.top();
                s.pop();
            }
            s.push(i);
        }
        return ans;
    }
};
```

* [207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/description/?envType=problem-list-v2&envId=2cktkvj)

这道题的本质是判断是否有环，但写成了是否通路

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<bool> a(numCourses, 1), b(numCourses);
        map<int, vector<int>> tree;
        for(int i = 0; i < prerequisites.size(); i++){
            tree[prerequisites[i][1]].emplace_back(prerequisites[i][0]);
            a[prerequisites[i][0]] = 0;
        }
        for(int i = 0; i < numCourses; i++){
            if(a[i]){
                queue<int> q;
                q.push(i);
                while(!q.empty()){
                    int top = q.front();
                    b[top] = 1;
                    for(auto j : tree[top]) 
                        q.push(j);
                    q.pop();
                }
            }
        }
        for(int i = 0; i < numCourses; i++){
            if(!b[i]) return 0;
        }
        return 1;
    }
};
```

* [155. 最小栈 - 力扣（LeetCode）](https://leetcode.cn/problems/min-stack/)[155. 最小栈 - 力扣（LeetCode）](https://leetcode.cn/problems/min-stack/)

没有考虑到小根堆和栈的stl的`pop`弹出是不一样的

```cpp
class MinStack {
    stack<int> s;
    priority_queue<int> p;
public:
    MinStack() {

    }

    void push(int val) {
        p.push(val);
        s.push(val);
    }

    void pop() {
        p.pop();
        s.pop();
    }

    int top() {
        return s.top();
    }

    int getMin() {
        return p.top();
    }
};
```

需要一个辅助栈记录每一个元素进入时，当前栈内的最小值。

```cpp
class MinStack {
    stack<int> s1, s2;
public:
    MinStack() {
        s2.push(INT_MAX);
    }

    void push(int val) {
        s1.push(val);
        s2.push(min(val, s2.top()));
    }

    void pop() {
        s1.pop(), s2.pop();
    }

    int top() {
        return s1.top();
    }

    int getMin() {
        return s2.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

## 更新节点

* 2025-01-24

* 2025-01-25

* 2025-01-26
