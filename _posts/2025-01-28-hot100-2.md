---
title: 'hot100'
date: 2025-01-28
permalink: /posts/2025/01/hot100-2/
tags:
  - coding
---

        2025-1-24开始刷hot100，计划2025-03-15前刷完。

# 非一遍过

* [152. 乘积最大子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-subarray/)

突然愣住了处理连续的负数相乘。直接开两个dp数组记录连续的最大整数积和最小整数乘积。

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int len = nums.size(), ans = nums[0];
        vector<int> a(len), b(len);
        for(int i = 0; i < len; i++){
            a[i] = nums[i], b[i] = nums[i];
        }  
        for(int i = 1; i < len; i++){
            if(a[i] > 0) {
                a[i] = max(a[i], a[i-1] * nums[i]);
                b[i] = min(b[i], b[i-1] * nums[i]);
            }
            else{
                a[i] = max(a[i], b[i-1] * nums[i]);
                b[i] = min(b[i], a[i-1] * nums[i]);
            } 
            ans = max(a[i], ans);
        }
        return ans;
    }
};
```

        考虑到可以再次优化内存空间，可以直接开两个数，因为只和上一个状态有关，可以不开数组，从O(N)变成O(1)。

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int len = nums.size(), ans = nums[0], a = 1, b = 1;
        int aa, bb;
        for(int i = 0; i < len; i++){
            if(nums[i] > 0) {
                aa = max(nums[i], a * nums[i]);
                bb = min(nums[i], b * nums[i]);
            }
            else{
                aa = max(nums[i], b * nums[i]);
                bb = min(nums[i], a * nums[i]);
            } 
            a = aa, b = bb;
            ans = max(a, ans);
        }
        return ans;
    }
};
```

* [148. 排序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-list/)

哎呀，排序只会sort，写了一个冒泡排序果然超时了$O(N^2)$。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode *node = head, *a, *b;
        int len = 0;
        while(node != nullptr){
            node = node -> next;
            len++;
        }
        for(int i = 0; i < len; i++){
            a = head, b = head;
            for(int j = 0; j < len - i - 1; j++){
                if(b->val > b->next->val){
                    int temp = b->val;
                    b->val = b->next->val;
                    b->next->val = temp;
                }
                b = b->next;
            }
        }
        return head;
    }
};
```

实在时不晓得别的啊，学一个手写归并。先找一个基础题目：

[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *head = new ListNode(), *node = head;
        while(list1 != nullptr && list2 != nullptr){
            if(list1 -> val < list2 -> val){
                node -> next = list1;
                list1 = list1 -> next;
            }
            else{
                node -> next = list2;
                list2 = list2 -> next;
            }
            node = node -> next;
        }
        if(list1 != nullptr) node -> next = list1;
        else node -> next = list2;
        return head -> next;
    }
};
```

接下来再利用二分进行归并排序$O(NlogN)$

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr) return head;
        return sortList(head, nullptr);
    }

    ListNode* sortList(ListNode* head, ListNode* tail) {
        if(head -> next == tail){ //只保留左边
            head -> next = nullptr;
            return head;
        }
        ListNode *l = head, *r = head;
        while(r != tail){
            l = l -> next, r = r -> next;
            if(r != tail) r = r -> next;
        }
        return merge(sortList(head, l),sortList(l, tail)); 
        //第一段尾部多加了一个值（l）
    }
    ListNode* merge(ListNode* list1, ListNode* list2) {
        ListNode *head = new ListNode(), *node = head;
        while(list1 != nullptr && list2 != nullptr){
            if(list1 -> val < list2 -> val){
                node -> next = list1;
                list1 = list1 -> next;
            }
            else{
                node -> next = list2;
                list2 = list2 -> next;
            }
            node = node -> next;
        }
        if(list1 != nullptr) node -> next = list1;
        else node -> next = list2;
        return head -> next;
    }
};
```



直接用的set存了一下

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        set<ListNode*> s;
        while(head != NULL){
            int temp = s.size();
            s.insert(head);
            if(s.size()==temp) return head;
            head = head -> next;
        }
        return NULL;
    }
};
```

但要求用O(1)的时间复杂度，学了一下快慢指针。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *head1 = head, *head2 = head;
        while(head2 != NULL){
            head1 = head1 -> next, head2 = head2 -> next;
            if(head2 != NULL) head2 = head2 -> next;
            if(head1 != NULL && head1 == head2) {
                 ListNode *node = head;
                while (node != head1) {
                    node = node -> next;
                    head1 = head1 -> next;
                }
                return node;
            }
        } 
        return NULL;
    }
};
```



# 一遍过

* [200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/)

经典BFS搜索

```cpp
class Solution {
public:
    bool vis[300][300];
    int next[4][2] = {{-1,0},{1,0},{0,1},{0,-1}};
    int numIslands(vector<vector<char>>& grid) {
        int ans = 0, h = grid.size(), w = grid[0].size();
        for(int i = 0; i < h; i++){
            for(int j = 0; j < w; j++){
                if(vis[i][j] || grid[i][j]=='0') continue;
                queue<pair<int,int>> q;
                q.push({i,j});
                while(!q.empty()){
                    pair<int,int> p = q.front();
                    q.pop();
                    for(int k = 0; k < 4; k++){
                        if(p.first + next[k][0] < h && p.second + next[k][1] < w && p.first + next[k][0] >= 0 && p.second + next[k][1] >= 0){
                            if(grid[p.first + next[k][0]][p.second + next[k][1]]=='1' && !vis[p.first + next[k][0]][p.second + next[k][1]]){
                                q.push({p.first + next[k][0], p.second + next[k][1]});
                                vis[p.first + next[k][0]][p.second + next[k][1]] = 1;
                            }
                        }
                    }
                }
                ans++;
            }
        }
        return ans;
    }
};
```

* [198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/)

经典dp

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int len = nums.size(), ans = 0;
        vector<int> dp(len, 0);
        for(int i = 0; i < len; i++){
            dp[i] = nums[i];
            for(int j = 0; j < i - 1; j++){
                dp[i] = max(dp[j] + nums[i], dp[i]);
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

写了一个很蠢的做法

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int len = nums.size(), temp = nums[0], sum = 0;
        for(auto i : nums){
            if(temp != i){
                sum = 0;
                temp = i;
            }
            sum++;
            if(sum>len/2) return i;
        }
        return 0;
    }
};
```

其实可以直接利用众数，直接返回

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
```

学了一下Boyer-Moore 算法，O(N)的时间复杂度，O(1)的空间复杂度。

        如果我们把众数记为`+1`，把其他数记为`−1`，将它们全部加起来，显然和大于 `0`，即如果一个数组有大于一半的数相同，那么任意删去两个不同的数字，新数组还是会有相同的性质。

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int a = nums[0], sum = 0;
        for(int num : nums){
            if(num == a) sum++;
            else {
                sum--;
                if (sum < 0){
                    a = num;
                    sum = 1;
                }
            }
        }
        return a;
    }
};
```

* [238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/)

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> a(nums.size()), b(nums.size()), ans(nums.size());
        a[0] = nums[0], b[nums.size() - 1] = nums[nums.size() - 1];
        for(int i = 1; i < nums.size(); i++){
            a[i] = a[i-1] * nums[i];
            b[nums.size() - 1 - i] = b[nums.size() - i] * nums[nums.size() - 1 - i];
        }
        ans[0] = b[1], ans[nums.size() - 1] = a[nums.size() - 2];
        for(int i = 1; i < nums.size() - 1; i++){
            ans[i] = a[i - 1] * b[i + 1];
        }
        return ans;
    }
};
```

变成O(1)的空间复杂度的话，就把反方向的乘法直接一个一个乘进ans数组里。

* [141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        set<ListNode*> s;
        while(head != NULL){
            int temp = s.size();
            s.insert(head);
            if(s.size()==temp) return true;
            head = head -> next;
        }
        return false;
    }
};
```



## 完成时间

* 2025-01-26
* 2025-01-28
