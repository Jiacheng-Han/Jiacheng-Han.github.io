---
title: '【2025-01-26 ~ 2025-01-28】hot100'
date: 2025-01-28
permalink: /posts/2025/01/hot100-2/
tags:
  - coding
---

        2025-1-24开始刷hot100，计划2025-03-15前刷完。

# 非一遍过

* [152. 乘积最大子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-subarray/)

突然愣住了处理连续的负数相乘。直接开两个dp数组记录连续的最大整数积和最小整数乘积。

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int len = nums.size(), ans = nums[0];
        vector<int> a(len), b(len);
        for(int i = 0; i < len; i++){
            a[i] = nums[i], b[i] = nums[i];
        }  
        for(int i = 1; i < len; i++){
            if(a[i] > 0) {
                a[i] = max(a[i], a[i-1] * nums[i]);
                b[i] = min(b[i], b[i-1] * nums[i]);
            }
            else{
                a[i] = max(a[i], b[i-1] * nums[i]);
                b[i] = min(b[i], a[i-1] * nums[i]);
            } 
            ans = max(a[i], ans);
        }
        return ans;
    }
};
```

        考虑到可以再次优化内存空间，可以直接开两个数，因为只和上一个状态有关，可以不开数组，从O(N)变成O(1)。

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int len = nums.size(), ans = nums[0], a = 1, b = 1;
        int aa, bb;
        for(int i = 0; i < len; i++){
            if(nums[i] > 0) {
                aa = max(nums[i], a * nums[i]);
                bb = min(nums[i], b * nums[i]);
            }
            else{
                aa = max(nums[i], b * nums[i]);
                bb = min(nums[i], a * nums[i]);
            } 
            a = aa, b = bb;
            ans = max(a, ans);
        }
        return ans;
    }
};
```

* [148. 排序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-list/)

哎呀，排序只会sort，写了一个冒泡排序果然超时了$O(N^2)$。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode *node = head, *a, *b;
        int len = 0;
        while(node != nullptr){
            node = node -> next;
            len++;
        }
        for(int i = 0; i < len; i++){
            a = head, b = head;
            for(int j = 0; j < len - i - 1; j++){
                if(b->val > b->next->val){
                    int temp = b->val;
                    b->val = b->next->val;
                    b->next->val = temp;
                }
                b = b->next;
            }
        }
        return head;
    }
};
```

实在时不晓得别的啊，学一个手写归并。先找一个基础题目：

[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *head = new ListNode(), *node = head;
        while(list1 != nullptr && list2 != nullptr){
            if(list1 -> val < list2 -> val){
                node -> next = list1;
                list1 = list1 -> next;
            }
            else{
                node -> next = list2;
                list2 = list2 -> next;
            }
            node = node -> next;
        }
        if(list1 != nullptr) node -> next = list1;
        else node -> next = list2;
        return head -> next;
    }
};
```

接下来再利用二分进行归并排序$O(NlogN)$

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr) return head;
        return sortList(head, nullptr);
    }

    ListNode* sortList(ListNode* head, ListNode* tail) {
        if(head -> next == tail){ //只保留左边
            head -> next = nullptr;
            return head;
        }
        ListNode *l = head, *r = head;
        while(r != tail){
            l = l -> next, r = r -> next;
            if(r != tail) r = r -> next;
        }
        return merge(sortList(head, l),sortList(l, tail)); 
        //第一段尾部多加了一个值（l）
    }
    ListNode* merge(ListNode* list1, ListNode* list2) {
        ListNode *head = new ListNode(), *node = head;
        while(list1 != nullptr && list2 != nullptr){
            if(list1 -> val < list2 -> val){
                node -> next = list1;
                list1 = list1 -> next;
            }
            else{
                node -> next = list2;
                list2 = list2 -> next;
            }
            node = node -> next;
        }
        if(list1 != nullptr) node -> next = list1;
        else node -> next = list2;
        return head -> next;
    }
};
```



直接用的set存了一下

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        set<ListNode*> s;
        while(head != NULL){
            int temp = s.size();
            s.insert(head);
            if(s.size()==temp) return head;
            head = head -> next;
        }
        return NULL;
    }
};
```

但要求用O(1)的时间复杂度，学了一下快慢指针。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *head1 = head, *head2 = head;
        while(head2 != NULL){
            head1 = head1 -> next, head2 = head2 -> next;
            if(head2 != NULL) head2 = head2 -> next;
            if(head1 != NULL && head1 == head2) {
                 ListNode *node = head;
                while (node != head1) {
                    node = node -> next;
                    head1 = head1 -> next;
                }
                return node;
            }
        } 
        return NULL;
    }
};
```

## 完成时间

* 2025-01-26
* 
* 2025-01-28
