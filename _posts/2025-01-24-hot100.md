---
title: 'hot100'
date: 2025-01-24
permalink: /posts/2025/01/hot100/
tags:
  - coding
---

        2025-1-24开始刷hot100，计划2025-03-15前刷完。最近一次更新是<u>2025-01-28</u>。

# 一眼不会写

* [221. 最大正方形 - 力扣（LeetCode）](https://leetcode.cn/problems/maximal-square/)

        没想到是dp 利用`min{dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}`就可以判断最右下角的`1`能否合一起构成一个大正方形，想到了还是比较easy的。

![fig1](https://assets.leetcode-cn.com/solution-static/221/221_fig1.png)

```cpp
class Solution {
public:
    int dp[300][300];
    int maximalSquare(vector<vector<char>>& matrix) {
        int ans=0;
        for(int i = 0; i < matrix.size(); i++){
            for(int j = 0; j < matrix[i].size(); j++){
                if(matrix[i][j]=='1'){
                    if(i==0||j==0) dp[i][j]=1;
                    else dp[i][j]=min(min(dp[i-1][j],dp[i-1][j-1]),dp[i][j-1]) + 1;
                }
                ans = max(ans,dp[i][j]);
            }
        }
        return ans * ans;
    }
};
```

# 非一边过

* [236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

        内存超限，给每一个节点的父节点都用栈存起来了。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
void check(TreeNode* node, map<TreeNode*, stack<TreeNode*>> &mp){
    if(node->left!=nullptr){
        mp[node->left] = mp[node];
        mp[node->left].push(node->left);
        check(node->left, mp);
    }
    if(node->right!=nullptr){
        mp[node->right] = mp[node];
        mp[node->right].push(node->right);
        check(node->right, mp);
    }
    return;
} 

class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        TreeNode* r = root;
        map<TreeNode*, stack<TreeNode*>> mp;
        check(root, mp);
        unordered_set<TreeNode*> s;
        while(!mp[p].empty()) {
            s.insert(mp[p].top());
            mp[p].pop();
        }
        while(!mp[q].empty()){
            if(s.count(mp[q].top())) return mp[q].top();
            mp[q].pop();
        }
        return root;
    }
};
```

        稍微修改了一点，看到题目中的键值各不相同，所以只存父节点指针。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */

class Solution {
public:
    map<int, TreeNode*> mp;

    void check(TreeNode* node){
        if(node->left!=nullptr){
            mp[node->left->val] = node;
            check(node->left);
        }
        if(node->right!=nullptr){
            mp[node->right->val] = node;
            check(node->right);
        }
        return;
    } 

    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        TreeNode* r = root;
        check(root);
        unordered_set<TreeNode*> s;
        TreeNode *i = p, *j = q;
        while(i!=nullptr) {
            s.insert(i);
            i = mp[i->val];
        }
        while(j!=nullptr){
            if(s.count(j)) return j;
            j = mp[j->val];
        }
        return root;
    }
};
```

* [739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/)

        没有想到非暴力做法，使用单调栈

```python
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> ans(n);
        stack<int> s;
        for(int i = 0; i < n; i++){
            while(!s.empty() && temperatures[i] > temperatures[s.top()]){
                ans[s.top()] = i - s.top();
                s.pop();
            }
            s.push(i);
        }
        return ans;
    }
};
```

* [207. 课程表 - 力扣（LeetCode）](https://leetcode.cn/problems/course-schedule/description/?envType=problem-list-v2&envId=2cktkvj)

        这道题的本质是判断是否有环，但写成了是否通路

```cpp
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<bool> a(numCourses, 1), b(numCourses);
        map<int, vector<int>> tree;
        for(int i = 0; i < prerequisites.size(); i++){
            tree[prerequisites[i][1]].emplace_back(prerequisites[i][0]);
            a[prerequisites[i][0]] = 0;
        }
        for(int i = 0; i < numCourses; i++){
            if(a[i]){
                queue<int> q;
                q.push(i);
                while(!q.empty()){
                    int top = q.front();
                    b[top] = 1;
                    for(auto j : tree[top]) 
                        q.push(j);
                    q.pop();
                }
            }
        }
        for(int i = 0; i < numCourses; i++){
            if(!b[i]) return 0;
        }
        return 1;
    }
};
```

* [155. 最小栈 - 力扣（LeetCode）](https://leetcode.cn/problems/min-stack/)[155. 最小栈 - 力扣（LeetCode）](https://leetcode.cn/problems/min-stack/)

        没有考虑到小根堆和栈的stl的`pop`弹出是不一样的

```cpp
class MinStack {
    stack<int> s;
    priority_queue<int> p;
public:
    MinStack() {

    }

    void push(int val) {
        p.push(val);
        s.push(val);
    }

    void pop() {
        p.pop();
        s.pop();
    }

    int top() {
        return s.top();
    }

    int getMin() {
        return p.top();
    }
};
```

        需要一个辅助栈记录每一个元素进入时，当前栈内的最小值。

```cpp
class MinStack {
    stack<int> s1, s2;
public:
    MinStack() {
        s2.push(INT_MAX);
    }

    void push(int val) {
        s1.push(val);
        s2.push(min(val, s2.top()));
    }

    void pop() {
        s1.pop(), s2.pop();
    }

    int top() {
        return s1.top();
    }

    int getMin() {
        return s2.top();
    }
};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```

- [152. 乘积最大子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-subarray/)

        突然愣住了处理连续的负数相乘。直接开两个dp数组记录连续的最大整数积和最小整数乘积。

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int len = nums.size(), ans = nums[0];
        vector<int> a(len), b(len);
        for(int i = 0; i < len; i++){
            a[i] = nums[i], b[i] = nums[i];
        }  
        for(int i = 1; i < len; i++){
            if(a[i] > 0) {
                a[i] = max(a[i], a[i-1] * nums[i]);
                b[i] = min(b[i], b[i-1] * nums[i]);
            }
            else{
                a[i] = max(a[i], b[i-1] * nums[i]);
                b[i] = min(b[i], a[i-1] * nums[i]);
            } 
            ans = max(a[i], ans);
        }
        return ans;
    }
};
```

        考虑到可以再次优化内存空间，可以直接开两个数，因为只和上一个状态有关，可以不开数组，从O(N)变成O(1)。

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int len = nums.size(), ans = nums[0], a = 1, b = 1;
        int aa, bb;
        for(int i = 0; i < len; i++){
            if(nums[i] > 0) {
                aa = max(nums[i], a * nums[i]);
                bb = min(nums[i], b * nums[i]);
            }
            else{
                aa = max(nums[i], b * nums[i]);
                bb = min(nums[i], a * nums[i]);
            } 
            a = aa, b = bb;
            ans = max(a, ans);
        }
        return ans;
    }
};
```

- [148. 排序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-list/)

        哎呀，排序只会sort，写了一个冒泡排序果然超时了O(N^2)。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        ListNode *node = head, *a, *b;
        int len = 0;
        while(node != nullptr){
            node = node -> next;
            len++;
        }
        for(int i = 0; i < len; i++){
            a = head, b = head;
            for(int j = 0; j < len - i - 1; j++){
                if(b->val > b->next->val){
                    int temp = b->val;
                    b->val = b->next->val;
                    b->next->val = temp;
                }
                b = b->next;
            }
        }
        return head;
    }
};
```

        实在时不晓得别的啊，学一个手写归并。先找一个基础题目：[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode *head = new ListNode(), *node = head;
        while(list1 != nullptr && list2 != nullptr){
            if(list1 -> val < list2 -> val){
                node -> next = list1;
                list1 = list1 -> next;
            }
            else{
                node -> next = list2;
                list2 = list2 -> next;
            }
            node = node -> next;
        }
        if(list1 != nullptr) node -> next = list1;
        else node -> next = list2;
        return head -> next;
    }
};
```

        接下来再利用二分进行归并排序O(NlogN)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == nullptr) return head;
        return sortList(head, nullptr);
    }

    ListNode* sortList(ListNode* head, ListNode* tail) {
        if(head -> next == tail){ //只保留左边
            head -> next = nullptr;
            return head;
        }
        ListNode *l = head, *r = head;
        while(r != tail){
            l = l -> next, r = r -> next;
            if(r != tail) r = r -> next;
        }
        return merge(sortList(head, l),sortList(l, tail)); 
        //第一段尾部多加了一个值（l）
    }
    ListNode* merge(ListNode* list1, ListNode* list2) {
        ListNode *head = new ListNode(), *node = head;
        while(list1 != nullptr && list2 != nullptr){
            if(list1 -> val < list2 -> val){
                node -> next = list1;
                list1 = list1 -> next;
            }
            else{
                node -> next = list2;
                list2 = list2 -> next;
            }
            node = node -> next;
        }
        if(list1 != nullptr) node -> next = list1;
        else node -> next = list2;
        return head -> next;
    }
};
```

        直接用的set存了一下

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        set<ListNode*> s;
        while(head != NULL){
            int temp = s.size();
            s.insert(head);
            if(s.size()==temp) return head;
            head = head -> next;
        }
        return NULL;
    }
};
```

        但要求用O(1)的时间复杂度，学了一下快慢指针。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *head1 = head, *head2 = head;
        while(head2 != NULL){
            head1 = head1 -> next, head2 = head2 -> next;
            if(head2 != NULL) head2 = head2 -> next;
            if(head1 != NULL && head1 == head2) {
                 ListNode *node = head;
                while (node != head1) {
                    node = node -> next;
                    head1 = head1 -> next;
                }
                return node;
            }
        } 
        return NULL;
    }
};
```

# 一遍过

* [160. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        set<ListNode*> s;
        for(ListNode *i = headA; i != NULL; i = i->next){
            s.insert(i);
        }
        int len = s.size();
        for(ListNode *i = headB; i != NULL; i = i->next){
            len = s.size();
            s.insert(i);
            if(len == s.size()) return i; 
        }
        return NULL;
    }
};
```

* [234. 回文链表 - 力扣（LeetCode）](https://leetcode.cn/problems/palindrome-linked-list/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* i = head;
        vector<int> v(1e6);
        int h = 1, t; 
        while(i!=nullptr){
            v[h++] = i->val;
            i = i -> next;
        }
        t = h - 1;
        h = 1;
        while(h < t){
            if(v[h++]!=v[t--]) return false;
        }
        return true;
    }
};
```

* [226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void f(TreeNode* root){
        if(root == NULL){
            return ;
        }
        f(root->left);
        f(root->right);
        TreeNode node = TreeNode(root->val, root->right, root->left);
        root->left = node.left;
        root->right = node.right;
    }

    TreeNode* invertTree(TreeNode* root) {
        f(root);
        return root; 
    }
};
```

* [215. 数组中的第K个最大元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

        大根堆

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, less<int>> p;
        for(auto i : nums) p.push(i);
        for(int i = 1; i < k; i++) p.pop();
        return p.top();
    }
};
```

* [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/)

        但我这个写法不是直接反转原本链表，而是重建了一个新的链表，原本链表没有删除。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *i = head, *temp = nullptr, *root = nullptr;
        while(i != NULL){
            root = new ListNode(i->val, temp);
            temp = root; 
            i = i->next;
        }
        return root;
    }
};
```

        直接反转原来的节点。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = nullptr, *curr = head;
        while(curr){
            ListNode *next = curr->next; //记录下一个节点的位置
            curr->next = pre; //修改当前节点
            pre = curr;
            curr = next;
        }
        return pre;
    }
};
```

* [200. 岛屿数量 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-islands/)

        经典BFS搜索

```cpp
//这个代码不知道为啥粘上来就报错
```

[198. 打家劫舍 - 力扣（LeetCode）](https://leetcode.cn/problems/house-robber/)

        经典dp

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int len = nums.size(), ans = 0;
        vector<int> dp(len, 0);
        for(int i = 0; i < len; i++){
            dp[i] = nums[i];
            for(int j = 0; j < i - 1; j++){
                dp[i] = max(dp[j] + nums[i], dp[i]);
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```

        写了一个很蠢的做法

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int len = nums.size(), temp = nums[0], sum = 0;
        for(auto i : nums){
            if(temp != i){
                sum = 0;
                temp = i;
            }
            sum++;
            if(sum>len/2) return i;
        }
        return 0;
    }
};
```

        其实可以直接利用众数，直接返回

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        return nums[nums.size() / 2];
    }
};
```

        学了一下Boyer-Moore 算法，O(N)的时间复杂度，O(1)的空间复杂度。

        如果我们把众数记为`+1`，把其他数记为`−1`，将它们全部加起来，显然和大于 `0`，即如果一个数组有大于一半的数相同，那么任意删去两个不同的数字，新数组还是会有相同的性质。

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int a = nums[0], sum = 0;
        for(int num : nums){
            if(num == a) sum++;
            else {
                sum--;
                if (sum < 0){
                    a = num;
                    sum = 1;
                }
            }
        }
        return a;
    }
};
```

- [238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/)

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> a(nums.size()), b(nums.size()), ans(nums.size());
        a[0] = nums[0], b[nums.size() - 1] = nums[nums.size() - 1];
        for(int i = 1; i < nums.size(); i++){
            a[i] = a[i-1] * nums[i];
            b[nums.size() - 1 - i] = b[nums.size() - i] * nums[nums.size() - 1 - i];
        }
        ans[0] = b[1], ans[nums.size() - 1] = a[nums.size() - 2];
        for(int i = 1; i < nums.size() - 1; i++){
            ans[i] = a[i - 1] * b[i + 1];
        }
        return ans;
    }
};
```

        变成O(1)的空间复杂度的话，就把反方向的乘法直接一个一个乘进ans数组里。

- [141. 环形链表 - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        set<ListNode*> s;
        while(head != NULL){
            int temp = s.size();
            s.insert(head);
            if(s.size()==temp) return true;
            head = head -> next;
        }
        return false;
    }
};
```

# 更新节点

* 2025-01-24

* 2025-01-25

* 2025-01-26

* 2025-01-28
